<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: azure key vault | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/azure-key-vault/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2016-01-21T00:02:48+11:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Managing User Permissions for Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/managing-user-permissions-for-key-vault/"/>
    <updated>2015-10-11T01:08:17+11:00</updated>
    <id>http://rahulpnath.com/blog/managing-user-permissions-for-key-vault</id>
    <content type="html"><![CDATA[<p>Granting access to different users to manage the key vault would be a typical scenario in an organization. This could either be to create new vaults or manage keys and secrets within an existing key vault. One way to do that would be to create an <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">AD application and use that to manage the vault</a>. Alternatively you would also want to add users to your azure subscription and grant them access for this (which was exactly what one of my readers wanted to achieve and reached out to me for).</p>

<p>In this post we will see how we can add a new user and grant him the required permissions. The permissions to be provided would differ based on your requirement, so you would want to modify them as required.</p>

<h4><strong>Creating the user</strong></h4>

<p><a href="https://azure.microsoft.com/en-us/documentation/articles/active-directory-create-users/">Creating a new user to the azure subscription</a> can easily be done from the <a href="https://manage.windowsazure.com">management portal</a>. We need to create the user in the azure subscription, as any resource in the subscription can be accessed only after authenticating against the Active Directory (AD) associated with it.</p>

<blockquote><p>Every Azure subscription is associated with an Azure Active Directory (AD) and needs to be authenticated with, before any of its resources can be used.</p></blockquote>

<p>Azure Key Vault gets created in the default AD associated with the subscription, so we need to add the new user to that. (If you are not sure on how to find the default AD <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">this post</a> describes it in the beginning). In the portal under the <em>Azure Directory</em> option, select the default directory and on the <em>Users</em> tab, we can add a new user.</p>

<p><img src="/images/ad_add_user.png" class="center"></img></p>

<p>When creating the user, you can <a href="https://azure.microsoft.com/en-us/documentation/articles/active-directory-assign-admin-roles/">assign the role required</a> based on the requirement. In this case I have added the user to a &lsquo;<em>User</em>&rsquo; role, as I do not want this user to have any administrative access to the my azure subscriptions or resources.</p>

<h4><strong>Creating the key vault</strong></h4>

<p>To create a key vault that we want to give permissions for the user, the below powershell scripts can be used. If you are new to key vault, then check out the <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Getting Started with Azure  Key Vault</a> or <a href="http://www.rahulpnath.com/blog/category/azure-key-vault/">other related articles</a>.</p>

<pre><code class="powershell">Switch-AzureMode AzureResourceManager
New-AzureResourceGroup –Name 'SharedGroup' –Location 'East Asia'
New-AzureKeyVault -VaultName 'TestKeyVault' -ResourceGroupName 
    'SharedGroup' -Location 'East Asia'
</code></pre>

<p>The above scripts creates the key vault under the &lsquo;<em>SharedGroup</em>&rsquo;. <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-overview/#resource-groups">Resource Groups</a> are logical containers, used to group resources together as required. <a href="https://azure.microsoft.com/en-us/documentation/articles/role-based-access-control-configure/">Access to azure resources</a> can be assigned at any of the three levels (subscription, resource group or resource) and it inherits down the hierarchy as shown below. Roles can be assigned specifically to a resource, or to resource group (which would mean all to all resources in that group) or at the subscription level (which would apply to all resources/resource groups in that subscription.).</p>

<p><a href="https://acomdpsstorage.blob.core.windows.net/dpsmedia-prod/azure.microsoft.com/en-us/documentation/articles/role-based-access-control-configure/20151006095042/rbacassignmentscopes.png"><img src="/images/rbac_assignment_scopes.png" class="center"></img></a></p>

<h4><strong>Setting Permission on the resource group</strong></h4>

<p>As an administrator I want the newly created user to have permission to interact with the key vault, but not create new or delete existing vaults. I would also want to give the user ability to modify keys and secrets within the vault. Currently since the new user does not have any rights, we should first give him rights to see the vaults in the <em>SharedGroup</em>. For this a <em>Reader</em> role from the set of <a href="https://azure.microsoft.com/en-us/documentation/articles/role-based-access-control-configure/#built-in-roles">built in roles</a> can be assinged, through the new azure portal or powershell.</p>

<pre><code class="powershell">New-AzureRoleAssignment -Mail keyvaultuser@domain.onmicrosoft.com 
    -RoleDefinitionName Reader -ResourceGroupName SharedGroup
</code></pre>

<p><img src="/images/resource_group_permission.png" class="center"></img></p>

<p>To modify objects (keys/secrets) in the key vault we need to run <a href="https://msdn.microsoft.com/en-us/library/dn903607.aspx">Set-AzureKeyVaultAccessPolicy</a> cmdlet with the required permissions, to grant access for the user. In the below script the user is given all Permissions to both keys and secrets, and this again depends on your requirement.</p>

<pre><code class="powershell">Set-AzureKeyVaultAccessPolicy -VaultName "TestKeyVault" -UserPrincipalName "keyvaultuser@domain.onmicrosoft.com" 
    -PermissionsToKeys all -PermissionsToSecrets all
</code></pre>

<h4><strong>Creating the key (new user)</strong></h4>

<p>The new user can login with the email id and password, shared to him by the administrator (received when creating the user in the AD), in the powershell prompt and create keys/secrets in the key vault.</p>

<pre><code class="powershell">$userName = 'keyvaultuser@domain.onmicrosoft.com'
$subscriptionPassword = 'mypassword'
$securePassword = ConvertTo-SecureString -String $subscriptionPassword -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential($userName, $securePassword)
Add-AzureAccount -Credential $cred
Add-AzureKeyVaultKey -VaultName 'TestKeyVault' -Name 'MyKey' -Destination 'Software'
</code></pre>

<p>The newly created user now has full access on the key vault and only that. He can only add/remove objects within the key vault and see resources within the SharedGroup. This way the administrator can be rest assured that no other sensitive information or accesses is being shared accidentally. Periodically revisiting these permissions and revoking unnecessary accesses is recommended!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MSDN Magazine Article on Azure Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/msdn-magazine-article-on-azure-key-vault/"/>
    <updated>2015-10-06T13:15:35+11:00</updated>
    <id>http://rahulpnath.com/blog/msdn-magazine-article-on-azure-key-vault</id>
    <content type="html"><![CDATA[<p>My first article on MSDN Magazine is published in the September 2015 edition and is available for <a href="https://msdn.microsoft.com/magazine/mt422585">reading online</a>. The article titled, &lsquo;<em>Microsoft Azure - Protect Sensitive Information with Azure Key Vault</em>&rsquo;, discusses on common problems in storing sensitive information in applications, benefits of Azure Key Vault and how we can quickly setup and start using it.</p>

<p>It was a great experience working with the MSDN magazine team, and got to learn a lot of things. Also special thanks to <a href="https://twitter.com/amitbapat">Amit Bapat</a> and <a href="https://twitter.com/sumedhbarde">Sumedh Barde</a> for doing the technical review and clarifying certain things for the article.</p>

<p><img src="/images/msdn_magazine_sep_2015.jpg" style="height:500px;" alt=""></p>

<p><em>If you are interested to <a href="http://blogs.msdn.com/b/msdnmagazine/archive/2009/12/24/9940803.aspx">write an article for the MSDN magazine</a></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing Azure AD Application for Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/managing-azure-ad-application-for-key-vault/"/>
    <updated>2015-06-27T23:43:48+10:00</updated>
    <id>http://rahulpnath.com/blog/managing-azure-ad-application-for-key-vault</id>
    <content type="html"><![CDATA[<p>Access to the Key Vault is secured using AD application token, as we had seen in the &lsquo;<a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Authenticating a Client Application with Azure Key Vault</a>&rsquo;. Quite often administrators require to manage the AD application created, performing activities like creating new AD applications, changing the certificate used to authenticate with the AD application, remove a certificate or even delete an application. All of these are possible using PowerShell scripts and administrators can even run this as part of their automation scripts. With the latest Azure PowerShell version(0.9.2 or higher), the Key Vault cmdlet&rsquo;s are included automatically and does not require any additional installations. For managing the Azure AD application we need to <a href="https://msdn.microsoft.com/en-us/library/azure/jj151815.aspx#bkmk_installmodule">install the Azure AD module for PowerShell</a> and import them into the PowerShell command prompt.</p>

<h4><strong>Creating AD application</strong></h4>

<p>The <em><a href="https://msdn.microsoft.com/en-us/library/dn986794.aspx">New-AzureADApplication</a></em> cmdlet is used to create a new Azure AD application. It also provides an option to specify the certificate details used to authenticate with the AD application at the time of creation itself. This can be done as a separate step if required, which is shown later in the post.</p>

<p>First we need a certificate that is to be used for authenticating against the AD application, for which I use the below commands to generate a test certificate</p>

<pre><code class="text">makecert -sv mykey.pvk -n "cn=AD Test Vault Application" ADTestVaultApplication.cer -b 03/03/2014 -e 06/05/2017 -r -len 2048
pvk2pfx -pvk mykey.pvk -spc ADTestVaultApplication.cer -pfx ADTestVaultApplication.pfx -po test
</code></pre>

<p>This certificate is then used to create the AD application using the below script.</p>

<pre><code class="powershell">$certificateFilePath = "C:\certificates\ADTestVaultApplication.cer"
$certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$certificate.Import($certificateFilePath)
$rawCertificateData = $certificate.GetRawCertData()
$credential = [System.Convert]::ToBase64String($rawCertificateData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
$adApplication = New-AzureADApplication -DisplayName "KeyVaultADApplication" 
  -HomePage  "http://www.rahulpnath.com" -IdentifierUris "http://www.rahulpnath.com"  
  -KeyValue  $credential -KeyType "AsymmetricX509Cert" -KeyUsage "Verify" 
  -StartDate $startDate -EndDate $endDate 
</code></pre>

<p>To associate the application created with the Key Vault, we need to create a service principal using <a href="https://msdn.microsoft.com/en-us/library/dn986799.aspx">New-AzureADServicePrincipal</a> and then associate that with the Vault using the <a href="https://msdn.microsoft.com/en-us/library/azure/dn903607.aspx">Set-AzureKeyVaultAccessPolicy</a></p>

<pre><code class="powershell">$servicePrincipal = New-AzureADServicePrincipal -ApplicationId $adApplication.ApplicationId
Set-AzureKeyVaultAccessPolicy -VaultName 'KeyVaultRahul' -ObjectId  $servicePrincipal.Id -PermissionsToKeys all -PermissionsToSecrets all
$ServicePrincipal.ApplicationId #Outputs the ServicePrincipalName/AppPrincipalId
</code></pre>

<h4><strong>Adding a Certificate</strong></h4>

<p>The <em><a href="https://msdn.microsoft.com/en-us/library/azure/dn194106.aspx">New-MsolServicePrincipalCredential</a></em> cmdlet is used to add a new credential to a service principal or to an application. The service principal is identified by supplying one of the following: object ID, appPrincipalID, service principal name (SPN).</p>

<pre><code class="powershell">$msolCredentials = get-credential
connect-msolservice -credential $msolCredentials
$certificateFilePath = "C:\certificates\ADTestVaultApplicationNew.cer"
$x509Certificate2 = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$x509Certificate2.Import($certificateFilePath)
$rawCertData = $x509Certificate2.GetRawCertData()
$credentialValue = [System.Convert]::ToBase64String($rawCertData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
New-MsolServicePrincipalCredential -ServicePrincipalName $ServicePrincipal.ApplicationId -Type Asymmetric -Value $credentialValue -StartDate $startDate -EndDate   $endDate 
</code></pre>

<h4><strong>Removing a Certificate</strong></h4>

<p>Whenever a credential gets compromised or as part of regular credential refresh, administrators would want to remove an old certificate and replace with a new one. The <a href="https://msdn.microsoft.com/en-us/library/azure/dn194125.aspx">Remove-MsolServicePrincipalCredential</a> cmdlet is used to remove a credential key from a service principal by specifying the key ID for the credential and the objectID/applicationID/ServicePrincipalName to identify the service principal. To get the key ID of an existing credential, <a href="https://msdn.microsoft.com/en-us/library/azure/dn194091.aspx">Get-MsolServicePrincipalCredential</a> cmdlet can be used, which returns the list of credentials associated with a service principal. The below script just removes the first credential, you could loop through and remove all.</p>

<pre><code class="powershell">$servicePrincipalCredential = Get-MsolServicePrincipalCredential -ServicePrincipalName $ServicePrincipal.ApplicationId -ReturnKeyValues 0
Remove-MsolServicePrincipalCredential -ServicePrincipalName $ServicePrincipal.ApplicationId -KeyIds $servicePrincipalCredential[0].KeyId
</code></pre>

<h4><strong>Delete an application</strong></h4>

<p>The <a href="https://msdn.microsoft.com/en-us/library/azure/dn194113.aspx">Remove-MsolServicePrincipal</a> cmdlet removes a service principal from Microsoft Azure Active Directory, by specifying objectID/applicationID/ServicePrincipalName to identify the service principal.</p>

<pre><code class="powershell">Remove-MsolServicePrincipal -ObjectId &lt;Guid&gt;
Or
Remove-MsolServicePrincipal -AppPrincipalId &lt;Guid&gt;
Or
Remove-MsolServicePrincipal -ServicePrincipalName &lt;string&gt;
</code></pre>

<p>Managing the AD application is a very important and necessary process in the life cycle of a Key Vault, as the access to the Vault is controlled using that. Certificates securing the AD applciation should be rolled/updated frequently and application permissions should be reviewed often to make sure that all applications have only the required permissions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault in a Real World Application]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-in-a-real-world-application/"/>
    <updated>2015-04-25T16:16:09+10:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-in-a-real-world-application</id>
    <content type="html"><![CDATA[<p>Over the last couple of posts we have seen how to <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Get Started with Azure Key Vault</a>, <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Authenticate a Client Application with the Vault</a> and also on how the vault can be used as an <a href="http://www.rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault/">alternate to the configuration file to keep sensitive information secure</a>. In this post we will explore into how a key vault can be fit into the life-cycle of an application, configuring application to use the keyvault for different deployments and also on how to manage the keys/secrets for these different deployments. Any application that uses the Key Vault to manage keys and other sensitive information, should be able to switch easily to use the vault configured for it.</p>

<h3>Configuring Client-Applications to use the Key vault</h3>

<p>Objects are uniquely identified within Azure Key Vault using a URL such that no two objects in the system, regardless of geo-location, have the same URL. The complete URL to an object is called the Object Identifier and consists of a prefix portion that identifies the Key Vault, the object type, a user provided Object Name, and an Object Version. The <em>object-name</em> is case-insensitive and immutable. When an object is first created it is given a unique version identifier and is marked as the current version of the object. Creation of a new instance with the same object name gives the new object a unique version identifier and causes it to become the current version. When querying for an object <em>object-version</em> is optional and if not provided will point to the current version of the given object-name.</p>

<blockquote>https://{keyvault-name}.vault.azure.net/{object-type}/{object-name}/{object-version}</blockquote>


<p>From a client application all we need to have is to the configuration for the key vault url, and configurations to identify key/secret name which can include the version if required. This could be saved in the application&rsquo;s configuration file as shown below.
<code>xml
&lt;appSettings&gt;
  &lt;add key="KeyVaultUrl" value="https://testvaultrahul.vault.azure.net"/&gt;
  &lt;add key="SqlConnectionString" value="SqlConnectionString"/&gt;
  &lt;add key ="SecretWithVersion" value="SecretWithVersion/cfedea84815e4ca8bc19cf8eb943ee13"/&gt;
  &lt;add key="CryptoKey" value="CryptoKey"/&gt;
&lt;/appSettings&gt;
</code></p>

<p>In the above configuration I assume that when these configurations are used from the code, we know that if a value is a key or secret. We could have an extended configuration or string prefix&rsquo;s (key<em> or secret</em>) to indicate this and then have the code automatically detect it too if required to decouple that, but I don&rsquo;t see it really necessary. So the application at any time would only depend on these configured values, and we can easily switch it use any vault configured with the required key/secret values.</p>

<pre><code class="csharp">var keyVaultIdentifierHelper = new KeyVaultIdentifierHelper(ConfigurationManager.AppSettings["KeyVaultUrl"]);
var connectionStringIdentifier =
    keyVaultIdentifierHelper.GetSecretIdentifier(ConfigurationManager.AppSettings["SqlConnectionString"]);
var connectionStringSecret = await keyClient.GetSecretAsync(connectionStringIdentifier);
</code></pre>

<pre><code class="csharp KeyVaultIdentifierHelper">public class KeyVaultIdentifierHelper
{
    private const string KeyFormat = "{0}/keys/{1}";
    private const string SecretFormat = "{0}/secrets/{1}";
    private readonly string keyVaultUrl;

    public KeyVaultIdentifierHelper(string keyVaultUrl)
    {
        this.keyVaultUrl = keyVaultUrl;
    }

    public string GetKeyIdentifier(string keyName)
    {
        return string.Format(KeyFormat, this.keyVaultUrl, keyName);
    }

    public string GetSecretIdentifier(string secretName)
    {
        return string.Format(SecretFormat, this.keyVaultUrl, secretName);
    }
}
</code></pre>

<h3>Managing the Key Vault for Multiple Deployments</h3>

<p>Now that we have decoupled the application from the Key Vault, we need to see how to configure key vaults to cater for multiple deployments. In any application development life-cycle, there would be multiple deployments at a given time for the application to cater for different roles - developers, testers and maybe a production one too. It is very likely that the connection strings and other sensitive information would be deployment specific and we would want to keep them separate. Best way to achieve this would be to create Key vault per deployment so that this separation is clearly maintained. You could check on the <a href="http://azure.microsoft.com/en-in/pricing/details/key-vault/">Key Vault Pricing</a> on how this would affect your overall cost. For each of these deployments you would need to make sure that all the required keys/secrets are added with valid values. Since this can soon end up as a repeated activity, it is best to automate this (using powershell scripts or your own application)</p>

<h3>Restricting Permissions to Key Vault</h3>

<p>We had seen how to <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">authenticate a client application with a Key Vault</a> using an Active Directory (AD) application, and how to set various access policies for these application&rsquo;s. Applications should be given only the minimum set of permissions that it requires to operate on, most probably this would be only the read permissions. For <a href="https://github.com/rahulpnath/AzureKeyVaultExplorer">administrative application&rsquo;s</a> we would want to give all permissions so that it can modify the vault keys/secrets as required. For such a scenario it is best to have, two (or more) separate AD application&rsquo;s created and have separate permissions provided.</p>

<p><img class="center" alt="Multiple AD applications to access key vault with different permissions" src="/images/multiple_ad_application.PNG" /></p>

<h3>What all should be there in my configuration file?</h3>

<p>All your <a href="http://www.rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault/">sensitive information should be moved out of your application configuration file</a>, and Key Vault is the one place to have them all. The application&rsquo;s configuration file should only have the azure key vault url and the AD application id and certificate identifier (thumb print) that can be used to authenticate with the AD. Yes it is advisable to use the <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">certificate authentication mechanism</a> as opposed to the secret mechanism, if not you would have to put the secret in your configuration file, which would be like &lsquo;giving a thief the key to your safe&rsquo;.Additionally you could also have the key identifier mappings in the configuration file that the application can use to map to key/secret in the vault as we had seen above.</p>

<p>By doing this we have fully decoupled the application and its dependency with the vault store and have also protected all our sensitive information. This also helps in having the application to be tested with configurations appropriate to the type of deployment. Hope this helps you in developing your application against the key vault.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Moving Sensitive Information from Configuration File to Azure Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault/"/>
    <updated>2015-03-14T23:04:23+11:00</updated>
    <id>http://rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault</id>
    <content type="html"><![CDATA[<p>Most of the applications today needs to use some kind of sensitive information like a database connection-string, api secret or passwords for it to connect to external service providers. Today we see that all these information are stored in the application&rsquo;s configuration file, which poses a huge security risk. Anyone having access to this configuration file could use this information to access sensitive data posing a security risk. Having understood this risk, we would not want to keep these secrets anymore in the application but move it to a safer and secure place. With <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Azure Key Vault</a>, we can have this information encrypted and saved safely out of the application and use as required from the application.Azure Key Vault provides a feature of saving such small data, <strong>Secrets</strong>, into the vault and access them over a secure endpoint.</p>

<blockquote><p>Secrets in Azure Key Vault are octet sequences with a maximum size of 10k bytes each and can have any data stored.</p></blockquote>

<p>If you are new to Azure Key Vault and yet to setup a vault, you could refer to <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Getting Started with Azure Key Vault</a>, to setup the vault and the Active Directory(AD) application that is used to authenticate our application to access the keyvault. Since in this case we are going to use Secrets from the key vault, while setting the key vault access policy for the the AD application, we need to explicitly set access for the application to use the secrets. Access Policy to secrets and keys are distinct and can be set accordingly and you can choose to have different application&rsquo;s to access keys and secrets separately. In the below script I have set the same application to have access to keys and secrets, by setting  <em>PermissionsToKeys</em> and <em>PermissionsToSecrets</em></p>

<pre><code class="powershell">Set-AzureKeyVaultAccessPolicy -VaultName 'TestVaultRahul' -ServicePrincipalName 'd4f09821-ab30-44f3-8d57-69925489b932' -PermissionsToKeys all -PermissionsToSecrets all
</code></pre>

<p>To create a secret in the Vault, you can use the powershell script command as shown below. On successful creation of the secret the identifier to the secret is returned, which can be used by the application to obtain the Secret value.Since we have given the AD application &lsquo;<em>all</em>&rsquo; access, we could also create the secret using the api client.</p>

<pre><code class="powershell">PS C:\&gt; $apiKey = ConvertTo-SecureString -String "ApiKey" -AsPlainText -Force
Set-AzureKeyVaultSecret -VaultName TestVaultRahul -Name "ApiKey" -SecretValue $apiKey

SecretValue     : System.Security.SecureString
SecretValueText : ApiKey
VaultName       : testvaultrahul
Name            : ApiKey
Version         : cfedea84815e4ca8bc19cf8eb943ee13
Id              : https://testvaultrahul.vault.azure.net/secrets/ApiKey/cfedea84815e4ca8bc19cf8eb943ee13
</code></pre>

<p>For the application to access this secret all it needs is the SecretIdentifier and the AD credentials to authenticate with the key vault. You would want to use <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">certificate based authentication</a> to authenticate against the AD application so that only the thumbprint information needs to be there in the application&rsquo;s configuration and not the secret itself as that is again a sensitive information.
&#8220;` csharp
var keyClient = new KeyVaultClient((authority, resource, scope) =>
{
    var authenticationContext = new AuthenticationContext(authority, null);
    var clientAssertionCertificate = new ClientAssertionCertificate(applicationId, certificate);
    var result = authenticationContext.AcquireToken(resource, clientAssertionCertificate);
});</p>

<p>var secret =
    await keyClient.GetSecretAsync(&ldquo;<a href="https://testvaultrahul.vault.azure.net/secrets/ApiKey/cfedea84815e4ca8bc19cf8eb943ee13">https://testvaultrahul.vault.azure.net/secrets/ApiKey/cfedea84815e4ca8bc19cf8eb943ee13</a>&rdquo;);
&#8220;`</p>

<p>No longer do we need to keep these sensitive information in the applications configuration file, we can just have the Secret Identifiers configured in the application and have the application fetch is as required from the vault. By doing this we have kept the sensitive information out of reach from the application and also from the people who have access to a production environment.</p>
]]></content>
  </entry>
  
</feed>
