<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: azure | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/azure/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2016-01-03T00:02:02+11:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Managing Azure AD Application for Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/managing-azure-ad-application-for-key-vault/"/>
    <updated>2015-06-27T23:43:48+10:00</updated>
    <id>http://rahulpnath.com/blog/managing-azure-ad-application-for-key-vault</id>
    <content type="html"><![CDATA[<p>Access to the Key Vault is secured using AD application token, as we had seen in the &lsquo;<a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Authenticating a Client Application with Azure Key Vault</a>&rsquo;. Quite often administrators require to manage the AD application created, performing activities like creating new AD applications, changing the certificate used to authenticate with the AD application, remove a certificate or even delete an application. All of these are possible using PowerShell scripts and administrators can even run this as part of their automation scripts. With the latest Azure PowerShell version(0.9.2 or higher), the Key Vault cmdlet&rsquo;s are included automatically and does not require any additional installations. For managing the Azure AD application we need to <a href="https://msdn.microsoft.com/en-us/library/azure/jj151815.aspx#bkmk_installmodule">install the Azure AD module for PowerShell</a> and import them into the PowerShell command prompt.</p>

<h4><strong>Creating AD application</strong></h4>

<p>The <em><a href="https://msdn.microsoft.com/en-us/library/dn986794.aspx">New-AzureADApplication</a></em> cmdlet is used to create a new Azure AD application. It also provides an option to specify the certificate details used to authenticate with the AD application at the time of creation itself. This can be done as a separate step if required, which is shown later in the post.</p>

<p>First we need a certificate that is to be used for authenticating against the AD application, for which I use the below commands to generate a test certificate</p>

<pre><code class="text">makecert -sv mykey.pvk -n "cn=AD Test Vault Application" ADTestVaultApplication.cer -b 03/03/2014 -e 06/05/2017 -r -len 2048
pvk2pfx -pvk mykey.pvk -spc ADTestVaultApplication.cer -pfx ADTestVaultApplication.pfx -po test
</code></pre>

<p>This certificate is then used to create the AD application using the below script.</p>

<pre><code class="powershell">$certificateFilePath = "C:\certificates\ADTestVaultApplication.cer"
$certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$certificate.Import($certificateFilePath)
$rawCertificateData = $certificate.GetRawCertData()
$credential = [System.Convert]::ToBase64String($rawCertificateData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
$adApplication = New-AzureADApplication -DisplayName "KeyVaultADApplication" 
  -HomePage  "http://www.rahulpnath.com" -IdentifierUris "http://www.rahulpnath.com"  
  -KeyValue  $credential -KeyType "AsymmetricX509Cert" -KeyUsage "Verify" 
  -StartDate $startDate -EndDate $endDate 
</code></pre>

<p>To associate the application created with the Key Vault, we need to create a service principal using <a href="https://msdn.microsoft.com/en-us/library/dn986799.aspx">New-AzureADServicePrincipal</a> and then associate that with the Vault using the <a href="https://msdn.microsoft.com/en-us/library/azure/dn903607.aspx">Set-AzureKeyVaultAccessPolicy</a></p>

<pre><code class="powershell">$servicePrincipal = New-AzureADServicePrincipal -ApplicationId $adApplication.ApplicationId
Set-AzureKeyVaultAccessPolicy -VaultName 'KeyVaultRahul' -ObjectId  $servicePrincipal.Id -PermissionsToKeys all -PermissionsToSecrets all
$ServicePrincipal.ApplicationId #Outputs the ServicePrincipalName/AppPrincipalId
</code></pre>

<h4><strong>Adding a Certificate</strong></h4>

<p>The <em><a href="https://msdn.microsoft.com/en-us/library/azure/dn194106.aspx">New-MsolServicePrincipalCredential</a></em> cmdlet is used to add a new credential to a service principal or to an application. The service principal is identified by supplying one of the following: object ID, appPrincipalID, service principal name (SPN).</p>

<pre><code class="powershell">$msolCredentials = get-credential
connect-msolservice -credential $msolCredentials
$certificateFilePath = "C:\certificates\ADTestVaultApplicationNew.cer"
$x509Certificate2 = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$x509Certificate2.Import($certificateFilePath)
$rawCertData = $x509Certificate2.GetRawCertData()
$credentialValue = [System.Convert]::ToBase64String($rawCertData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
New-MsolServicePrincipalCredential -ServicePrincipalName $ServicePrincipal.ApplicationId -Type Asymmetric -Value $credentialValue -StartDate $startDate -EndDate   $endDate 
</code></pre>

<h4><strong>Removing a Certificate</strong></h4>

<p>Whenever a credential gets compromised or as part of regular credential refresh, administrators would want to remove an old certificate and replace with a new one. The <a href="https://msdn.microsoft.com/en-us/library/azure/dn194125.aspx">Remove-MsolServicePrincipalCredential</a> cmdlet is used to remove a credential key from a service principal by specifying the key ID for the credential and the objectID/applicationID/ServicePrincipalName to identify the service principal. To get the key ID of an existing credential, <a href="https://msdn.microsoft.com/en-us/library/azure/dn194091.aspx">Get-MsolServicePrincipalCredential</a> cmdlet can be used, which returns the list of credentials associated with a service principal. The below script just removes the first credential, you could loop through and remove all.</p>

<pre><code class="powershell">$servicePrincipalCredential = Get-MsolServicePrincipalCredential -ServicePrincipalName $ServicePrincipal.ApplicationId -ReturnKeyValues 0
Remove-MsolServicePrincipalCredential -ServicePrincipalName $ServicePrincipal.ApplicationId -KeyIds $servicePrincipalCredential[0].KeyId
</code></pre>

<h4><strong>Delete an application</strong></h4>

<p>The <a href="https://msdn.microsoft.com/en-us/library/azure/dn194113.aspx">Remove-MsolServicePrincipal</a> cmdlet removes a service principal from Microsoft Azure Active Directory, by specifying objectID/applicationID/ServicePrincipalName to identify the service principal.</p>

<pre><code class="powershell">Remove-MsolServicePrincipal -ObjectId &lt;Guid&gt;
Or
Remove-MsolServicePrincipal -AppPrincipalId &lt;Guid&gt;
Or
Remove-MsolServicePrincipal -ServicePrincipalName &lt;string&gt;
</code></pre>

<p>Managing the AD application is a very important and necessary process in the life cycle of a Key Vault, as the access to the Vault is controlled using that. Certificates securing the AD applciation should be rolled/updated frequently and application permissions should be reviewed often to make sure that all applications have only the required permissions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault in a Real World Application]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-in-a-real-world-application/"/>
    <updated>2015-04-25T16:16:09+10:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-in-a-real-world-application</id>
    <content type="html"><![CDATA[<p>Over the last couple of posts we have seen how to <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Get Started with Azure Key Vault</a>, <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Authenticate a Client Application with the Vault</a> and also on how the vault can be used as an <a href="http://www.rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault/">alternate to the configuration file to keep sensitive information secure</a>. In this post we will explore into how a key vault can be fit into the life-cycle of an application, configuring application to use the keyvault for different deployments and also on how to manage the keys/secrets for these different deployments. Any application that uses the Key Vault to manage keys and other sensitive information, should be able to switch easily to use the vault configured for it.</p>

<h3>Configuring Client-Applications to use the Key vault</h3>

<p>Objects are uniquely identified within Azure Key Vault using a URL such that no two objects in the system, regardless of geo-location, have the same URL. The complete URL to an object is called the Object Identifier and consists of a prefix portion that identifies the Key Vault, the object type, a user provided Object Name, and an Object Version. The <em>object-name</em> is case-insensitive and immutable. When an object is first created it is given a unique version identifier and is marked as the current version of the object. Creation of a new instance with the same object name gives the new object a unique version identifier and causes it to become the current version. When querying for an object <em>object-version</em> is optional and if not provided will point to the current version of the given object-name.</p>

<blockquote>https://{keyvault-name}.vault.azure.net/{object-type}/{object-name}/{object-version}</blockquote>


<p>From a client application all we need to have is to the configuration for the key vault url, and configurations to identify key/secret name which can include the version if required. This could be saved in the application&rsquo;s configuration file as shown below.
<code>xml
&lt;appSettings&gt;
  &lt;add key="KeyVaultUrl" value="https://testvaultrahul.vault.azure.net"/&gt;
  &lt;add key="SqlConnectionString" value="SqlConnectionString"/&gt;
  &lt;add key ="SecretWithVersion" value="SecretWithVersion/cfedea84815e4ca8bc19cf8eb943ee13"/&gt;
  &lt;add key="CryptoKey" value="CryptoKey"/&gt;
&lt;/appSettings&gt;
</code></p>

<p>In the above configuration I assume that when these configurations are used from the code, we know that if a value is a key or secret. We could have an extended configuration or string prefix&rsquo;s (key<em> or secret</em>) to indicate this and then have the code automatically detect it too if required to decouple that, but I don&rsquo;t see it really necessary. So the application at any time would only depend on these configured values, and we can easily switch it use any vault configured with the required key/secret values.</p>

<pre><code class="csharp">var keyVaultIdentifierHelper = new KeyVaultIdentifierHelper(ConfigurationManager.AppSettings["KeyVaultUrl"]);
var connectionStringIdentifier =
    keyVaultIdentifierHelper.GetSecretIdentifier(ConfigurationManager.AppSettings["SqlConnectionString"]);
var connectionStringSecret = await keyClient.GetSecretAsync(connectionStringIdentifier);
</code></pre>

<pre><code class="csharp KeyVaultIdentifierHelper">public class KeyVaultIdentifierHelper
{
    private const string KeyFormat = "{0}/keys/{1}";
    private const string SecretFormat = "{0}/secrets/{1}";
    private readonly string keyVaultUrl;

    public KeyVaultIdentifierHelper(string keyVaultUrl)
    {
        this.keyVaultUrl = keyVaultUrl;
    }

    public string GetKeyIdentifier(string keyName)
    {
        return string.Format(KeyFormat, this.keyVaultUrl, keyName);
    }

    public string GetSecretIdentifier(string secretName)
    {
        return string.Format(SecretFormat, this.keyVaultUrl, secretName);
    }
}
</code></pre>

<h3>Managing the Key Vault for Multiple Deployments</h3>

<p>Now that we have decoupled the application from the Key Vault, we need to see how to configure key vaults to cater for multiple deployments. In any application development life-cycle, there would be multiple deployments at a given time for the application to cater for different roles - developers, testers and maybe a production one too. It is very likely that the connection strings and other sensitive information would be deployment specific and we would want to keep them separate. Best way to achieve this would be to create Key vault per deployment so that this separation is clearly maintained. You could check on the <a href="http://azure.microsoft.com/en-in/pricing/details/key-vault/">Key Vault Pricing</a> on how this would affect your overall cost. For each of these deployments you would need to make sure that all the required keys/secrets are added with valid values. Since this can soon end up as a repeated activity, it is best to automate this (using powershell scripts or your own application)</p>

<h3>Restricting Permissions to Key Vault</h3>

<p>We had seen how to <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">authenticate a client application with a Key Vault</a> using an Active Directory (AD) application, and how to set various access policies for these application&rsquo;s. Applications should be given only the minimum set of permissions that it requires to operate on, most probably this would be only the read permissions. For <a href="https://github.com/rahulpnath/AzureKeyVaultExplorer">administrative application&rsquo;s</a> we would want to give all permissions so that it can modify the vault keys/secrets as required. For such a scenario it is best to have, two (or more) separate AD application&rsquo;s created and have separate permissions provided.</p>

<p><img class="center" alt="Multiple AD applications to access key vault with different permissions" src="/images/multiple_ad_application.PNG" /></p>

<h3>What all should be there in my configuration file?</h3>

<p>All your <a href="http://www.rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault/">sensitive information should be moved out of your application configuration file</a>, and Key Vault is the one place to have them all. The application&rsquo;s configuration file should only have the azure key vault url and the AD application id and certificate identifier (thumb print) that can be used to authenticate with the AD. Yes it is advisable to use the <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">certificate authentication mechanism</a> as opposed to the secret mechanism, if not you would have to put the secret in your configuration file, which would be like &lsquo;giving a thief the key to your safe&rsquo;.Additionally you could also have the key identifier mappings in the configuration file that the application can use to map to key/secret in the vault as we had seen above.</p>

<p>By doing this we have fully decoupled the application and its dependency with the vault store and have also protected all our sensitive information. This also helps in having the application to be tested with configurations appropriate to the type of deployment. Hope this helps you in developing your application against the key vault.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Moving Sensitive Information from Configuration File to Azure Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault/"/>
    <updated>2015-03-14T23:04:23+11:00</updated>
    <id>http://rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault</id>
    <content type="html"><![CDATA[<p>Most of the applications today needs to use some kind of sensitive information like a database connection-string, api secret or passwords for it to connect to external service providers. Today we see that all these information are stored in the application&rsquo;s configuration file, which poses a huge security risk. Anyone having access to this configuration file could use this information to access sensitive data posing a security risk. Having understood this risk, we would not want to keep these secrets anymore in the application but move it to a safer and secure place. With <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Azure Key Vault</a>, we can have this information encrypted and saved safely out of the application and use as required from the application.Azure Key Vault provides a feature of saving such small data, <strong>Secrets</strong>, into the vault and access them over a secure endpoint.</p>

<blockquote><p>Secrets in Azure Key Vault are octet sequences with a maximum size of 10k bytes each and can have any data stored.</p></blockquote>

<p>If you are new to Azure Key Vault and yet to setup a vault, you could refer to <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Getting Started with Azure Key Vault</a>, to setup the vault and the Active Directory(AD) application that is used to authenticate our application to access the keyvault. Since in this case we are going to use Secrets from the key vault, while setting the key vault access policy for the the AD application, we need to explicitly set access for the application to use the secrets. Access Policy to secrets and keys are distinct and can be set accordingly and you can choose to have different application&rsquo;s to access keys and secrets separately. In the below script I have set the same application to have access to keys and secrets, by setting  <em>PermissionsToKeys</em> and <em>PermissionsToSecrets</em></p>

<pre><code class="powershell">Set-AzureKeyVaultAccessPolicy -VaultName 'TestVaultRahul' -ServicePrincipalName 'd4f09821-ab30-44f3-8d57-69925489b932' -PermissionsToKeys all -PermissionsToSecrets all
</code></pre>

<p>To create a secret in the Vault, you can use the powershell script command as shown below. On successful creation of the secret the identifier to the secret is returned, which can be used by the application to obtain the Secret value.Since we have given the AD application &lsquo;<em>all</em>&rsquo; access, we could also create the secret using the api client.</p>

<pre><code class="powershell">PS C:\&gt; $apiKey = ConvertTo-SecureString -String "ApiKey" -AsPlainText -Force
Set-AzureKeyVaultSecret -VaultName TestVaultRahul -Name "ApiKey" -SecretValue $apiKey

SecretValue     : System.Security.SecureString
SecretValueText : ApiKey
VaultName       : testvaultrahul
Name            : ApiKey
Version         : cfedea84815e4ca8bc19cf8eb943ee13
Id              : https://testvaultrahul.vault.azure.net/secrets/ApiKey/cfedea84815e4ca8bc19cf8eb943ee13
</code></pre>

<p>For the application to access this secret all it needs is the SecretIdentifier and the AD credentials to authenticate with the key vault. You would want to use <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">certificate based authentication</a> to authenticate against the AD application so that only the thumbprint information needs to be there in the application&rsquo;s configuration and not the secret itself as that is again a sensitive information.
&#8220;` csharp
var keyClient = new KeyVaultClient((authority, resource, scope) =>
{
    var authenticationContext = new AuthenticationContext(authority, null);
    var clientAssertionCertificate = new ClientAssertionCertificate(applicationId, certificate);
    var result = authenticationContext.AcquireToken(resource, clientAssertionCertificate);
});</p>

<p>var secret =
    await keyClient.GetSecretAsync(&ldquo;<a href="https://testvaultrahul.vault.azure.net/secrets/ApiKey/cfedea84815e4ca8bc19cf8eb943ee13">https://testvaultrahul.vault.azure.net/secrets/ApiKey/cfedea84815e4ca8bc19cf8eb943ee13</a>&rdquo;);
&#8220;`</p>

<p>No longer do we need to keep these sensitive information in the applications configuration file, we can just have the Secret Identifiers configured in the application and have the application fetch is as required from the vault. By doing this we have kept the sensitive information out of reach from the application and also from the people who have access to a production environment.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Authenticating a Client Application with Azure Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/"/>
    <updated>2015-03-06T17:10:25+11:00</updated>
    <id>http://rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault</id>
    <content type="html"><![CDATA[<p>Azure Key Vault provides an easy way for managing cryptographic keys and secrets (like connection strings or passwords) in a secure and distributed manner as opposed to having them in the configuration file or a database. If you are new to Azure Key Vault check out the <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Getting Started with Azure Key Vault</a> on how to setup the vault and add keys and use that from a console application.</p>

<p>In this post we will explore into the ways of authenticating a client application with a key vault. For an application to use the key vault it must authenticate using a token from the Azure Active Directory (AD). For this an application needs to be registered in the Azure AD and this application needs to be authorized to access key or secret in the vault using the <a href="https://msdn.microsoft.com/en-us/library/azure/dn903607.aspx">Set-AzureKeyVaultAccessPolicy</a> that comes as part of the <a href="https://gallery.technet.microsoft.com/scriptcenter/Azure-Key-Vault-Powershell-1349b091">key vault powershell scripts</a>.</p>

<blockquote><p>As of today, the keyvault will be created in the Default AD associated to the azure subscription and there is no way that it can be created in a different directory. But maybe this will be <a href="https://social.msdn.microsoft.com/Forums/azure/en-US/21d0dcaa-791c-4f96-8f9d-738b6b0076b2/create-a-new-key-vault-in-a-different-directory?forum=AzureKeyVault">supported in future</a>.</p></blockquote>

<p>So for a client to access the key vault, it needs to obtain the token from the Azure AD application, which can be done using 2 ways:</p>

<ul>
<li>Using ClientId and secret</li>
<li>Using ClientId and certificate</li>
</ul>


<h4><strong>Using ClientId and Secret</strong></h4>

<p>Creating an application that can be authenticated using clientid and secret can be done using the management portal. In the azure management portal, we need to create to the application under the default AD. To find the default AD you can check under the settings in the portal</p>

<p><img class="center" alt="Default Active Directory under Settings" src="/images/default_ad_settings.PNG" /></p>

<p>To add an application in the default, under Active Directory select the default AD and the applications tab and select &lsquo;<em>Add an application</em>&rsquo;.</p>

<p><img class="center" alt="Create an Application under default" src="/images/default_ad.PNG" /></p>

<p>From the pop-up select &lsquo;<em>Add an application my organization is developing</em>&rsquo; and give a name of your choice and of type &lsquo;<em>Web Application AND/OR WEB API</em>&rsquo;. In the App properties window it asks for the &lsquo;<em>Sign-On Url</em>&rsquo; and &lsquo;<em>App ID Uri</em>&rsquo;, for which you can give two unique values and is not mandatory that it should exists. On confirming these values the AD application would be created and you would be presented with the application properties. Under the &lsquo;<em>Configure</em>&rsquo; tab, you can see the Client ID and below that there is an option to create the &lsquo;<em>keys</em>&rsquo; which will be the secret.</p>

<p><img class="center" alt="AD Application Configure" src="/images/ad_application_configure.PNG" /></p>

<p>In the drop-down under the keys select the duration and choose a duration of your choice and save. On saving the secret will be generated. Copy this secret and keep for reference to use in the client application.</p>

<p><img class="center" alt="AD Application Secret Generation" src="/images/ad_application_keys.PNG" /></p>

<p>Now that we have created the application and have the clientid and the secret we need to authorize the application to access the key vault. For this we use the <em>Set-AzureKeyVaultAccessPolicy</em> from the powershell and provide the client id of the application that we have just created. The <em>PermissionToKeys</em> parameter determines the permission that the application would have on the keys in the vault which can take multiple comma separated values (all, backup, create, decrypt, delete, encrypt, import, get, list, restore, sign, wrapkey, unwrapkey, update and verify). Similarly for access to secrets in the keyvault you need to set <em>PermissionToSecrets</em> which can all take multiple values (all, delete, get, list and set).</p>

<pre><code class="powershell">PS C:\&gt; Set-AzureKeyVaultAccessPolicy -VaultName 'TestVaultRahul' -ServicePrincipalName '01c74fc1-4fb3-455e-8612-d5ad05a7fe2a' -PermissionsToKeys all
</code></pre>

<p>Now using the clientid and the secret we can authenticate from the client application using it as below
<code>csharp
var keyClient = new KeyVaultClient((authority, resource, scope) =&gt;
{
    var adCredential = new ClientCredential(clientid, applicationSecret);
    var authenticationContext = new AuthenticationContext(authority, null);
    return authenticationContext.AcquireToken(resource, adCredential).AccessToken;
});
</code></p>

<h4><strong>Using ClientId and Certificate</strong></h4>

<p>Creating an application that can be authenticated using the clientid and the certificate is only possible using powershell scripts, and these are again available with the key vault powershell scripts. For this we first need to create a certificate or if your organization already has provided one use that. Since this is for demo I would be creating a test certificate as <a href="https://msdn.microsoft.com/en-in/library/ff699202.aspx">explained here</a>.
<code>
makecert -sv mykey.pvk -n "cn=AD Test Vault Application" ADTestVaultApplication.cer -b 03/03/2014 -e 06/05/2016 -r
pvk2pfx -pvk mykey.pvk -spc ADTestVaultApplication.cer -pfx ADTestVaultApplication.pfx -po test
</code></p>

<p>Once we have the certificate, we can create a new AD application and specify certificate authentication for the application as shown below. Make sure that you give the full path to the certificate as below (mine was located under C:\cert)</p>

<pre><code class="powershell">Connect-AzureAD -DomainName '&lt;domainname&gt;'
$newADApplication = New-AzureADApplication -DisplayName 'TestVaultApplication'
Add-AzureADApplicationCredential -ObjectId $newADApplication.objectId -FilePath C:\cert\ADTestVaultApplication.cer
$newADApplication.appId
</code></pre>

<p>Once the application is created, we need to perform the same authorization steps as above to give the application access to the key vault, after which we can use the clientid (that would be output to the powershell console) and the certificate to authenticate the application. Make sure that the certificate is installed into the store so that it can be used by the application.</p>

<pre><code class="csharp">var keyClient = new KeyVaultClient((authority, resource, scope) =&gt;
{
    var authenticationContext = new AuthenticationContext(authority, null);
    X509Certificate2 certificate;
    X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
    try
    {
        store.Open(OpenFlags.ReadOnly);
        X509Certificate2Collection certificateCollection = store.Certificates.Find(X509FindType.FindByThumbprint, "E2F3EAE0A131EE0CF1FF1995A6ABA9F9462A0C03", false);
        if (certificateCollection == null || certificateCollection.Count == 0)
        {
            throw new Exception("Certificate not installed in the store");
        }

        certificate = certificateCollection[0];
    }
    finally
    {
        store.Close();
    }

    var clientAssertionCertificate = new ClientAssertionCertificate(applicationId, certificate);
    var result = authenticationContext.AcquireToken(resource, clientAssertionCertificate);
    return result.AccessToken;
});
</code></pre>

<p>You could use either ways to authenticate an application to Azure Key Vault. Using the certificate way would be more secure as you can also password protect your certificate so that it cannot be installed without having that. If using the client secret anybody having access to the configuration would be able to access the vault. Also make sure that you give the application&rsquo;s only necessary permissions for accessing keys and secrets while registering the application. You could use the sample used in the <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Getting Started with Azure Key Vault</a> <a href="https://github.com/rahulpnath/Blog/tree/master/AzureKeyVault">sample</a>. The code in there uses clientId and secret, you could change it with the above code to use certificate authentication.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started with Azure Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/getting-started-with-azure-key-vault/"/>
    <updated>2015-01-25T23:52:06+11:00</updated>
    <id>http://rahulpnath.com/blog/getting-started-with-azure-key-vault</id>
    <content type="html"><![CDATA[<p>Azure Key Vault service is a cloud hosted, HSM(Hardware Security Modules)-backed service for managing cryptographic keys and other secrets. With Azure Key Vault, the process of managing and controlling the keys required for an application or multiple applications for an enterprise can be handled at a centralized place. Also these sensitive information no longer needs to be exposed in the application&rsquo;s configuration file or in database. Keys can be created in the vault and accessed via url&rsquo;s by the required application. Operations against the Key Vault are authenticated and authorized using Azure Active Directory. So in short all that a developer would need to know are the URI&rsquo;s for the keys, the <a href="https://msdn.microsoft.com/en-us/library/azure/dn903625.aspx">sdk/api</a> to access the vault features and also on the mechanism to authenticate against the AD application (an appId/client secret or appId/certificate).</p>

<p><img class="center" alt="Azure Key Vault Overview" src="/images/azurekeyvault_overview.png" /></p>

<h3>Key Types</h3>

<p>The initial release of Azure Key Vault only supports RSA keys (asymmetric cryptography) - it supports both software and HSM processed keys, and are represented as JSON Web Key objects. In future there might be more support for the different key types that are there in cryptography. For those who are new to cryptography or needs a quick recap on cryptography algorithms:</p>

<h5><strong>Symmetric Cryptography</strong></h5>

<p>Symmetric cryptography, uses the same key to encrypt and decrypt the data. The keys are shared between the identities that require to transfer the encrypted data.</p>

<p><img class="center" alt="Symmetric Encryption" src="/images/symmetric_encryption.png" /></p>

<h5><strong>Asymmetric Cryptography</strong></h5>

<p>Asymmetric cryptography, also known as public key cryptography uses two separate keys - a public key and private key. The public key can be used to encrypt the data or to verify a digital signature whereas the private key is used to decrypt the text or to digital sign.</p>

<p><img class="center" alt="Asymmetric Encryption" src="/images/asymmetric_encryption.png" /></p>

<p>To create a new key in the Azure Key Vault, first we need to create the vault, using powershell scripts. You would need to install <a href="http://www.rahulpnath.com/blog/azure-key-vault-and-powershell-module-version/">azure module version 0.8.13 version or higher</a> for the key vault scripts to execute. Detailed steps on creating the vault and keys is documented <a href="http://azure.microsoft.com/en-in/documentation/articles/key-vault-get-started/">here</a>. Once we have the key created we can get the attributes of the key, using <em>Get-AzureKeyVaultKey</em>. This is as per the <a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-key-41#page-25">JSON Web Key(JWK) format</a>. The &lsquo;<em>n/e</em>&rsquo; values in the below key are for the RSA key type(<em>kty</em>), showing the public key information.</p>

<pre><code class="powershell">PS C:\&gt; Get-AzureKeyVaultKey -Name rahulkey -VaultName testvaultrahul                                                                                                     


Attributes : Microsoft.Azure.Commands.KeyVault.Models.KeyAttributes                                                                                                       
Key        : {"kid":"https://testvaultrahul.vault.azure.net/keys/rahulkey/0f653b06c1d94159bc7090596bbf7784","kty":"RSA","key_ops":["encrypt","decrypt","sign","verify","w 
             rapKey","unwrapKey"],"n":"xAXdHg5IAiU44GLM41hrCgfbEf8vg414lwIXBRHwPH-GTdQo3x5hMyvEtT26udcWLeRDDYGQxquuQ03ChXmXaE1Z8rdDpuaciJVoTB8wA_icr4Ww4ld0zuk9Nf31sVP-T_ 
             UiYBpg_3MdwbDvO53udtknLWnXEa-Y-NXlCwUus6LOtfoG1_oVg5B5OFfcW993Zb44C3ZMoOESa-fW0eT6OefBJOgXwGG5gB-zAB2D7uzhStu3Cp4OiFELQSAS4gpt2GCUI76YkTfq8jnIJ7bi5cYzUb-Sv2 
             9nkiwJV9I7hN6wuoz1gNRoJJVisBtidiFd8EYYuCGB3AH8OWbWS_sXEw","e":"AQAB"}                                                                                        
VaultName  : testvaultrahul                                                                                                                                               
Name       : rahulkey                                                                                                                                                     
Version    : 0f653b06c1d94159bc7090596bbf7784                                                                                                                             
Id         : https://testvaultrahul.vault.azure.net/keys/rahulkey/0f653b06c1d94159bc7090596bbf7784                                                                                                                                               
</code></pre>

<h3>Key Operations</h3>

<p>Now that we have a key in the vault, we can use this to perform different operations allowed on the key, as provided in the <em>key_ops</em> field in the key details above. Typical operations that can be performed using the key are Encrypt, Decrypt, Sign, Verify, WrapKey and UnWrapKey. For an application to use the key vault keys, it needs to authenticate using a token from the Azure Active Directory. For this we first need to <a href="http://azure.microsoft.com/en-us/documentation/articles/key-vault-get-started/#register">register an application with azure active directory</a> and then use the Application id and Authentication key(client secret) to authenticate against the AD application. Instead of using the  key/secret, this could also be through a certificate authentication, which might be a more preferred approach(For the simplicity of this demo will use the application id and the secret directly). To connect to the AD application we can use the <a href="https://www.nuget.org/packages/Microsoft.IdentityModel.Clients.ActiveDirectory/2.14.201151115">Active Directory Authentication Library</a> nuget package, the KeyVault libraries are availalble as part of the <a href="http://www.microsoft.com/en-us/download/details.aspx?id=45343">samples</a>.</p>

<pre><code class="csharp">var keyClient = new KeyVaultClient((authority, resource, scope) =&gt;
{
    var adCredential = new ClientCredential(applicationId, applicationSecret);
    var authenticationContext = new AuthenticationContext(authority, null);
    return authenticationContext.AcquireToken(resource, adCredential).AccessToken;
});

// Get the key details
var keyIdentifier = "https://testvaultrahul.vault.azure.net/keys/rahulkey/0f653b06c1d94159bc7090596bbf7784";
var key = await keyClient.GetKeyAsync(keyIdentifier);
var publicKey = Convert.ToBase64String(key.Key.N);
</code></pre>

<p>The application first uses the AD application credentials to authenticate and obtain the token for further interacting with the key vault. Using the key identifier that is available we get the details of the key.For performing the get operation the &lsquo;<em>PermissionToKeys</em>&rsquo;, should be set appropriately when registering the AD application, using Set-AzureKeyVaultAccessPolicy, against the key vault. Since this is RSA asymmetric algorithm, we have the public key available to us, and we can use this to encrypt the data or to verify the signature, locally in the application itself, though the vault client provides this for convenience.</p>

<pre><code class="csharp">using (var rsa = new RSACryptoServiceProvider())
{
    var p = new RSAParameters() { Modulus = key.Key.N, Exponent = key.Key.E };
    rsa.ImportParameters(p);
    var byteData = Encoding.Unicode.GetBytes(textToEncrypt);

    // Encrypt and Decrypt
    var encryptedText = rsa.Encrypt(byteData, true);
    var decryptedData = await keyClient.DecryptDataAsync(keyIdentifier, "RSA_OAEP", encryptedText);
    var decryptedText = Encoding.Unicode.GetString(decryptedData.Result);

    // Sign and Verify
    var hasher = new SHA256CryptoServiceProvider();
    var digest = hasher.ComputeHash(byteData);
    var signature = await keyClient.SignAsync(keyIdentifier, "RS256", digest);
    var isVerified = rsa.VerifyHash(digest, "Sha256", signature.Result);
</code></pre>

<p>As above, we use the public key available to create the <a href="https://msdn.microsoft.com/en-us/library/System.Security.Cryptography.RSACryptoServiceProvider(v=vs.110).aspx">RSACryptoServiceProvider</a> to encrypt the data and also to verify the signature locally. So in an application we can encrypt the data locally and use the vault to decrypt it when required. Decryption can happen only from the vault, as the private key is only available in the vault, and does not cross the vault boundary.</p>

<p>With Azure Key Vault, managing keys and restricting application permission for keys can be easily managed and no information needs to be passed on to the developer or to any specific individual. Also the keys are secure behind the vault service and can also be protected using a HSM. You would need to update the application id and secret in the <a href="https://github.com/rahulpnath/Blog/tree/master/AzureKeyVault">sample</a> for it to work. Hope this helps in getting you started with Azure Key Vault.</p>
]]></content>
  </entry>
  
</feed>
