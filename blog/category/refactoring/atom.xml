<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: refactoring | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/refactoring/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2016-03-31T04:21:22+11:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Refactoring Test Code: Removing Constructor Dependency]]></title>
    <link href="http://rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency/"/>
    <updated>2016-03-31T04:18:00+11:00</updated>
    <id>http://rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency</id>
    <content type="html"><![CDATA[<p><a href="https://www.flickr.com/photos/toomore/23066277453" class="center" title="Image By Toomore Chiang, from https://www.flickr.com/photos/toomore/23066277453"><img src="/images\testing.jpg" class="center" alt="Testing"></a></p>

<p>In the earlier post, <a href="http://rahulpnath.com/blog/refactoring-to-improve-testability-removing-unnecessary-dependencies/">Removing Unnecessary Dependencies</a>, we saw how having an unnecessary dependency hinders testability. In this post we will see how the test code changed by the refactoring we did for removing the unnecessary dependency and explore ways to control these changes.</p>

<h3>Impact on Tests by the Refactoring</h3>

<p>The refactoring in the last post involved a change in the updating the constructor signature to take in a string value instead of an interface. This broke a lot of our tests and forced us to change all constructor usages with the below code.</p>

<pre><code class="csharp">var anonymousName = "Anonymous Name";
myService = new MyService(otherDependency, anonymousName);
</code></pre>

<p>When seen in isolation, this is not much a change, but as the number of tests grows it becomes a pain. This definitely does not feel right. Breaking tests forces us out of <a href="http://xunitpatterns.com/test%20first%20development.html">Test-First Development</a> and reduces the confidence in the tests and in the code.</p>

<blockquote><p><em>The idea behind TDD was <a href="http://www.jamesshore.com/Blog/Red-Green-Refactor.html">Red-Green-Refactor</a>. But if tests break when Refactoring, then why follow TDD at all?</em></p></blockquote>

<h3>Refactoring Tests</h3>

<p>Ideally, we should write tests that do not break when we refactor, so that it helps us to use the same tests over the refactored code. Let&rsquo;s see how we can improve the test code to prevent tests from breaking, when we refactor to <a href="http://rahulpnath.com/blog/refactoring-to-improve-testability-removing-unnecessary-dependencies/">remove unnecessary dependency</a>. Below is the original code (<em>rewritten into xUnit and Moq, as I prefer that</em>) with the dependency on IAppSettings (which we will change it to string later)</p>

<pre><code class="csharp">[Fact]
public void PerformOperationsShouldReturnTrue()
{
    var otherDependency = new Mock&lt;IMyOtherDependency&gt;();
    var appSettings = new Mock&lt;IAppSettings&gt;();
    appSettings.Setup(a =&gt; a["app.name"]).Returns("My Test Application");
    var myService = new MyService(otherDependency, appSettings);

    var result = myService.PerformOperations();

    otherDependency.Verify(a =&gt; a.UtilityMethod(), Times.Once());
    Assert.True(result);
}
</code></pre>

<p>Let&rsquo;s analyze the test code for the dependencies that it has:</p>

<ul>
<li><em>UtilityMethod</em> of IMyOtherDependency</li>
<li><em>app.name</em> configuration value from IAppSettings</li>
<li><em>Constructor</em> of <a href="http://xunitpatterns.com/SUT.html">System Under Test</a>(SUT) - MyService</li>
<li><em>PerformOperations</em> of SUT which is getting tested</li>
</ul>


<p>The test by itself verifies that calling <em>PerformOperations</em> returns true and UtilityMethod gets called once. It is not dependent on the value (&lsquo;My Test Application&rsquo;) returned by appSettings. The only need is that it should return some (dummy) value when asked for &lsquo;app.name&rsquo;. Assuming that there are multiple tests in this class that does the same setup of IAppSettings to return a dummy value you can start smelling <em>Cut-and-Paste code reuse for fixture setup</em>.</p>

<blockquote><p><em>Rule of Three: “The first time you do something, you just do it. Second time you do something similar, you wince at the duplication, but you do the duplicate thing anyway. The third time you do something similar, you refactor.”</em></p></blockquote>

<p>The <a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming">Rule of Three</a> is applicable even when writing test code and we should always keep an eye for duplication. <strong>It is easy to get lost in the thought that it&rsquo;s just test code and does not hurt to copy paste</strong>. Code duplication in test code does hurt and it hurts the most when you refactor production code.</p>

<p>So lets Refactor applying the <a href="http://www.refactoring.com/catalog/">various techniques</a> that we know of!</p>

<h4><strong><a href="http://www.refactoring.com/catalog/extractMethod.html">Extract Method</a></strong></h4>

<p><em>You have a code fragment that can be grouped together. Turn the fragment into a method whose name explains the purpose of the method.</em></p>

<p>Since we only depend on the <em>IMyOtherDependency</em> and the SUT instance instantiated with that, we can extract SUT creation with a given instance of IMyOtherDependency as below.</p>

<pre><code class="csharp">[Fact]
public void PerformOperationsShouldReturnTrue()
{
    var otherDependency = new Mock&lt;IMyOtherDependency&gt;();
    var myService = GetMyServiceWithMyOtherDependency(otherDependency);

    var result = myService.PerformOperations();

    otherDependency.Verify(a =&gt; a.UtilityMethod(), Times.Once());
    Assert.True(result);
}

private MyService GetMyServiceWithMyOtherDependency(Mock&lt;IMyOtherDependency&gt; otherDependency)
{
    var appSettings = new Mock&lt;IAppSettings&gt;();
    appSettings.Setup(a =&gt; a["app.name"]).Returns("My Test Application");
    var myService = new MyService(otherDependency, appSettings);
    return myService;
}
</code></pre>

<p>This starts taking us towards <strong><a href="http://martinfowler.com/bliki/ObjectMother.html">Object Mother Pattern</a></strong>. It looks good to start with and might work well if all we have is the same <a href="http://xunitpatterns.com/Fixture%20Setup%20Patterns.html">fixture setup</a>. But if we have a different kind of fixture setup, with more dependency and combinations of setup, we will soon have a lot of similar creational methods with different combinations of parameters  - <em>GetMyServiceWithMyOtherDependencyAndAppSettings,GetMyServiceWithAppSettings</em> etc. The problem with having different methods is that all of them are dependent on the SUT constructor and set the same properties, leading to code duplication again.</p>

<h4><strong><a href="http://www.refactoring.com/catalog/extractClass.html">Extract Class</a></strong></h4>

<p><em>You have one class doing work that should be done by two. Create a new class and move the relevant fields and methods from the old class into the new class.</em></p>

<p>With these new creational methods the test class is having more responsibility than it should actually have, so let&rsquo;s extract these creation methods into <em>MyServiceBuilder</em> class to see if we can further solve the problem.</p>

<pre><code class="csharp">public class MyServiceBuilder
{
    public IAppSettings AppSettings { get; private set; }
    public IMyOtherDependency OtherDependency { get; private set; }

    public MyServiceBuilder()
    {
        var appsettingsMock = new Mock&lt;IAppSettings&gt;();
        appsettingsMock.Setup(a =&gt; a["app.name"]).Returns("My Test Application");
        AppSettings = appsettingsMock.Object;
        OtherDependency = new Mock&lt;IMyOtherDependency&gt;().Object;
    }

    public MyService Build()
    {
        return new MyService(OtherDependency, AppSettings);
    }

    public MyServiceBuilder WithAppSettings(IAppSettings appSettings)
    {
        AppSettings = appSettings;
        return this;
    }

    public MyServiceBuilder WithOtherDependency(IMyOtherDependency otherDependency)
    {
        OtherDependency = otherDependency;
        return this;
    }
}
</code></pre>

<p>This takes us to <strong><a href="http://www.natpryce.com/articles/000714.html">Test Data Builder Pattern</a></strong> and as we notice we have reduced the dependency on the MyService constructor to just one and only place where we need to change if the constructor signature changes. Since the <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic Complexity</a> of <em>MyServiceBuilder</em> is one it is fine not to write tests for it   . Using the new builder class our original test case now looks like below.</p>

<pre><code class="csharp">[Fact]
public void PerformOperationsShouldReturnTrue()
{
    var otherDependency = new Mock&lt;IMyOtherDependency&gt;();
    var myService = new MyServiceBuilder().WithOtherDependency(otherDependency.Object).Build();

    var result = myService.PerformOperations();

    otherDependency.Verify(a =&gt; a.UtilityMethod(), Times.Once());
    Assert.True(result);
}
</code></pre>

<p>Now the test is just dependent on the objects that it needs. If all the test use <em>MyServiceBuilder</em>, we can now easily refactor to <a href="http://rahulpnath.com/blog/refactoring-to-improve-testability-removing-unnecessary-dependencies/">Remove the Unnecessary Dependency</a> on IAppSettings, by just changing the <em>MyServiceBuilder</em> to use a string property. We will also need to change tests that use the <em>WithAppSettings</em> method which is expected, as those tests are dependent on the app settings value in the first place and so the tests definitely need to be re-written.</p>

<h3>Generic Test Data Builder</h3>

<p>We could have essentially stopped at the above step, but then we realize that it is too much work to create a Test Data Builder class for each of the production code classes that we have. It takes a lot out of the <a href="http://keysleft.com/">finite number of keystrokes left in your hands</a> and you definitely don&rsquo;t want to waste that in typing redundant code. This is where we can use
<a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a>, that is an open source library for .NET that helps reduce the <a href="http://xunitpatterns.com/Four%20Phase%20Test.html">Setup</a>/<a href="http://c2.com/cgi/wiki?ArrangeActAssert">Arrange</a> phase. Using <a href="http://blog.ploeh.dk/2010/10/08/AutoDataTheorieswithAutoFixture/">AutoData Theories with AutoFixture</a> our test case now looks like below.</p>

<pre><code class="csharp">[Theory, AutoMoqData]
public void PerformOperationsShouldReturnTrue(
    [Frozen]Mock&lt;IMyOtherDependency&gt; otherDependency,
    MyService myService)
{
    var result = myService.PerformOperations();

    otherDependency.Verify(a =&gt; a.UtilityMethod(), Times.Once());
    Assert.True(result);
}
</code></pre>

<p>The test code does not have any dependency on the constructor of the SUT and a change in constructor signature does not affect our tests at all. We can refactor <em>MyService</em> and use the same tests as long as the functionality served by the class remains the same. Constructors are implementation details and it&rsquo;s better to keep tests independent of it. This keeps our test code clean and more robust!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactoring to Improve Testability: Removing Unnecessary Dependencies]]></title>
    <link href="http://rahulpnath.com/blog/refactoring-to-improve-testability-removing-unnecessary-dependencies/"/>
    <updated>2016-03-28T04:27:00+11:00</updated>
    <id>http://rahulpnath.com/blog/refactoring-to-improve-testability-removing-unnecessary-dependencies</id>
    <content type="html"><![CDATA[<p><a href="https://unsplash.com/photos/5Ntkpxqt54Y" class="center" title="Image By Sai Kiran Anagani, from https://unsplash.com/photos/5Ntkpxqt54Y"><img src="/images\refactoring.jpg" class="center" alt="Refactoring"></a></p>

<p>Nowadays I am trying to stick to <a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd">TDD</a> (with the test first approach) and have found it to be of great help. One of the biggest reward doing TDD is that it helps me to <a href="https://vimeo.com/97419151">stay in the flow</a> and regain speed faster after a distraction. This post explains how to refactor code to remove unnecessary dependencies, which is easily found when writing tests.</p>

<p>Unnecessary dependencies are those components which a <a href="http://xunitpatterns.com/SUT.html">SUT</a> depends on, but does not directly affect any of its functionalities. Some of the common tests smell (from XUnit Test Patterns by Gerard Meszaros, <a href="http://www.rahulpnath.com/blog/language-agnostic-books-for-every-developer-2/">a recommended read</a>) that helps me to find these dependencies are <a href="http://xunitpatterns.com/Test%20Code%20Duplication.html">Test Code Duplication</a> and <a href="http://xunitpatterns.com/Fragile%20Test.html">Fragile Tests</a>.</p>

<blockquote><p><em>Cut-and-Paste code reuse for fixture setup happens often when there is an unnecessary dependency.</em></p></blockquote>

<p>While looking for an example to write on, I came across a post from my friend <a href="https://twitter.com/zpbappi">Bappi</a>, where he explains <a href="http://zpbappi.com/testing-codes-with-configurationmanager-appsettings/">Testing Codes with ConfigurationManager</a>. It&rsquo;s a good read on how to remove the dependency with various Configuration Providers by creating an abstraction over it.</p>

<h3>Testability Issues with Current Design</h3>

<p>While abstracting the Configuration Manager by using an interface is a good idea, you should also be careful on how the application classes depend on it. Configurations live at the application root and it is a good idea to restrict dependencies with it at that level. Rest of the application must be dependent only on the configuration value and not the configuration itself. Inner components having dependency with the  configuration provider brings in unnecessary complexities and makes code fragile. Some common issues are</p>

<ul>
<li>Class needs to know of Configuration key</li>
<li>Extra mocking while testing</li>
</ul>


<p>As you see below, the test case from the original post has to set up the Configuration provider mock to return values before testing the class. MyService (assuming that it is not a Factory class, which I confirmed from Bappi) is unnecessarily depending on IAppSettings and coupling itself with the configuration name, which really is not its concern. This leads to brittle code and tests!</p>

<pre><code class="csharp">[Subject(typeof(MyService))]
public class MyServiceTests
{
    Establish context = () =&gt;
        {
            otherDependency = Substitute.For&lt;IMyOtherDependency&gt;();

            var appSettings = Substitute.For&lt;IAppSettings&gt;();
            appSettings["app.name"].Returns("My Test Application");

            myService = new MyService(otherDependency, appSettings);
        };

    Because of = () =&gt; result = myService.PerformOperations();

    It should_call_my_dependency_utility_method_once = () =&gt; otherDependency.Received(1).UtilityMethod();
    It should_execute_successfully = () =&gt; result.ShouldBeTrue();
}
</code></pre>

<h3>Refactoring the Code</h3>

<p>Refactoring such code is as easy as removing the dependency on IAppSettings and taking in the value of &lsquo;app.name&rsquo; as the dependency. This removes the interface dependency and requires only the string value to be passed in. Here I am passing in <a href="https://blogs.msdn.microsoft.com/ploeh/2008/11/17/anonymous-variables/">an anonymous Name</a>, as the value is not of concern for this test.</p>

<pre><code class="csharp">[Subject(typeof(MyService))]
public class MyServiceTests
{
    Establish context = () =&gt;
        {
            otherDependency = Substitute.For&lt;IMyOtherDependency&gt;();
            var anonymousName = "Anonymous Name";
            myService = new MyService(otherDependency, anonymousName);
        };

    Because of = () =&gt; result = myService.PerformOperations();

    It should_call_my_dependency_utility_method_once = () =&gt; otherDependency.Received(1).UtilityMethod();
    It should_execute_successfully = () =&gt; result.ShouldBeTrue();
}
</code></pre>

<blockquote><p><em>When looked at isolation these are minor code changes that hardly removes a line or two. But it has a cumulative effect when applied to all the tests for the class and makes code more robust.</em></p></blockquote>

<p>When looked at isolation, this is a seemingly minor change of not mocking an interface and is just one line of code, which you could live with. But you need to mock that for all tests of that class, which is when you start to see the real benefit. Also, you have made the tests more resilient by not taking an unnecessary dependency. Even if you decide to change the configuration name to &lsquo;<em>ApplicationName</em>&rsquo;, none of the tests break now, whereas with the original code all of them would have.</p>

<p><em>One possible argument with this refactoring is, <strong> What if I need an extra value from the dependency (app.domain in the above case), I now have to update the class constructor</strong>.</em></p>

<p>Agreed, but then this violates <a href="https://blog.8thlight.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html">Open Closed Principle</a>, which states &lsquo;You should be able to extend a classes behaviour without modifying it.&rsquo; If you need a new configuration value, you are essentially changing the components functionality, so you should either extend current functionality or write a new component. This also opens up a hidden code smell with the existing code and an anti-pattern - <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/">Service Locator</a>. So the refactoring still holds good!</p>

<p>Hope this helps you find dependencies with unnecessary components and remove them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Replace ‘Introduce Local Extension’ With ‘Extension Methods’]]></title>
    <link href="http://rahulpnath.com/blog/replace-introduce-local-extension-with-extension-methods/"/>
    <updated>2010-08-25T23:04:00+10:00</updated>
    <id>http://rahulpnath.com/blog/replace-introduce-local-extension-with-extension-methods</id>
    <content type="html"><![CDATA[<p>Introduce Foreign Method(<a href="http://www.refactoring.com/catalog/introduceForeignMethod.html">IFM</a>) and Introduce Local Extension(<a href="http://www.refactoring.com/catalog/introduceLocalExtension.html">ILE</a>) are two refactoring techniques that comes handy when you need to add functionality to an exisiting class,source code of which is beyond your control.
IFM is used when its just one or two functions that you need to add to the class.When the number of functions,that are to be added are more,then ILE is used.Not a rule though :)
But now with <a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx">Extension Methods</a> the whole process is much more simpler.
You need not do the subclassing or wrapper technique of ILE.
This can be a third way of implementing ILE :).Thanks to the framework team for keeping it simple.
The same date example using the &lsquo;Extension Methods&rsquo; way of refactoring</p>

<pre><code class="csharp">public static class MyExtensionMethods
   {
     public static DateTime NextDay(this DateTime date)
     {
      return new DateTime(date.Year, date.Month, date.Day+1);
     }
   }
</code></pre>

<p>The function NextDay is now available on any DateTime object,just as if you have written if you had access to the source code. It&rsquo;s the usage of ILE and IFM that has paved way for the inclusion of Extension Methods in the framework I guess.Thanks to <a href="http://martinfowler.com/">Fowler </a>for that.
<a href="http://anyurl.com">CodeProject</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TDD and Refactoring]]></title>
    <link href="http://rahulpnath.com/blog/tdd-and-refactoring/"/>
    <updated>2010-08-23T20:42:00+10:00</updated>
    <id>http://rahulpnath.com/blog/tdd-and-refactoring</id>
    <content type="html"><![CDATA[<p>Over the days I have been reading on Test Driven Development(TDD) and it seems really interesting methodology to go with as per development is concerned.<br/>
Basic of TDD is that the development process relies on &lsquo;tests&rsquo;, that are written prior to code.<br/>
Sounds astonishing!!!!<br/>
It might to someone into the normal development mode,where tests are usually written after code, so as to match the code that is written.<br/>
But TDD says just the opposite.<br/>
Code to make the tests pass&hellip;Just pass..<em>Nothing more and Nothing less</em>.<br/>
Thats where the catch is where most of we developers might find it difficult and needs getting used to.Not getting more into it as I would not be the best to comment on it :)<br/>
So whats refactoring got to do here.<br/>
Refactoring plays an integral part of TDD,so that the code is elegant and conveys just what it needs to,avoiding duplication.<br/>
The TDD approach also assists in refactoring as you have tests readily available to assure that the functional behaviour is not affected while changing the code design.You are just click of a button away if you are having a automated test scripts (like nUnit) in veryfying refactoring. <br/>
So both TDD and Refactoring goes hand in hand and helps in greatly improving the overall code quality.<br/>
There are quite a lot resources out there on these.<br/>
The best for refactoring would be of <a href="http://www.amazon.com/gp/product/0201485672/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201485672&amp;linkCode=as2&amp;tag=rahulpnath-20">Refactoring: Improving the Design of Existing Code</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=rahulpnath-20&amp;l=as2&amp;o=1&amp;a=0201485672" alt="" />.<br/>
For TDD <a href="http://www.amazon.com/gp/product/0735619484/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0735619484&amp;linkCode=as2&amp;tag=rahulpnath-20">Test-Driven Development in Microsoft  .NET (Microsoft Professional)</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=rahulpnath-20&amp;l=as2&amp;o=1&amp;a=0735619484" alt="" /> would be a good start and also the one by Kent Beck <a href="http://www.amazon.com/gp/product/0321146530/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321146530&amp;linkCode=as2&amp;tag=rahulpnath-20">Test Driven Development: By Example</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=rahulpnath-20&amp;l=as2&amp;o=1&amp;a=0321146530" alt="" /></p>
]]></content>
  </entry>
  
</feed>
